'use strict';
// var noderedis = require('redis');
// var client = noderedis.createClient();
// client.multi().get('foo').set('foo').get('foo').exec(console.log);
// client.multi().set('foo', 'bar').lpush('foo', 1).exec(console.log);

var Redis = require('./');
var redis = new Redis();
// redis.pipeline().set(new Buffer('foo')).exec(function () {
//   console.dir(arguments, { depth: 10 });
// });
redis.pipeline().set('foo', 'bar').getBuffer('foo').exec(function () {
  console.log(arguments);
  // console.dir(arguments[1][0][0].command.args[0]);
  // console.dir(new Buffer('foo'));
});
// redis.multi().set('foo').set('foo', 'new value').exec(function (err, results) {
//   console.log('=', err);
//   // err === new Error('...Transaction discarded because of previous errors.');
//     /* err is: { [ReplyError: EXECABORT Transaction discarded because of previous errors.] }
//        res is undefined
//     */
// });
// var redis = new Redis();

// redis.disconnect();
// setTimeout(function () {
//   redis.get('foo', function () {
//     console.log(arguments);
//   });
// }, 1000);

// setTimeout(function () {
// }, 100000);

// redis.on('error', function () {
//   console.log('error', arguments);
// });

// redis.on('timeout', function () {
//   console.log('timeout', arguments);
// });

// redis.on('close', function () {
//   console.log('close', arguments);
// });

// redis.on('connect', function () {
//   console.log('connect', arguments);
// });
// var redis = new Redis();
// var redis = new Redis({
//   sentinels: [
//     { host: 'localhost', port: 26379 }
//   ],
//   name: 'master1'
// });

// redis.set('foo', 'bar');
// setInterval(function () {
//   redis.get('foo', console.log);
// }, 1000);

// setTimeout(function () {
//   console.log('start');
//   var pending = 0;
//   for (var i = 0; i < 3000; ++i) {
//     pending += 1;
//     doo(function () {
//       if (!--pending) {
//         console.log('done');
//       }
//     });
//   }
// }, 10000);


// function doo(callback) {
//   var pending = 0;
//   for (var j = 0; j < 50; ++j) {
//     pending += 1;
//     redis.set('foo', 'bar', function () {
//       if (!--pending) {
//         callback();
//       }
//     });
//   }
// }

// setInterval(function () {
//   redis.get('foo', function () {
//     console.log(arguments);
//   });
// }, 2000);
// var redis = new Redis({ showFriendlyErrorStack: 10 });
// var redis = new Redis();
// Redis.Promise.onPossiblyUnhandledRejection(function(error){
//   console.log(error);
// });

// redis.set('foo');
// var redis = new Redis();

// redis.blpop('que1', 0, function () {
//   console.log(arguments);
// });

// redis.blpop('que1', 'que2', 10, function(){console.log('blpop', arguments)});

// var redis = new Redis();
// redis.multi().set('foo').get('foo').exec(console.log);
// redis.multi().set('foo', 'bar').lpush('foo', 1).exec(console.log);
// redis.set(new Buffer('foo'), '你好', function () {
//   console.log(arguments);
//   redis.get('foo', console.log);
// });
// var pub = new Redis();

// redis.set('foo', function () {
//   console.log(arguments);
// });

// redis.subscribe('foo', 'bar', function () {
//   console.log(arguments);
//   redis.unsubscribe('foo', 'bar', function () {
//     console.log(arguments);
//     redis.set('foo', 'bar', function (err) {
//       console.log(arguments);
//     });
//   });
// });

// redis.on('message', function () {
//   console.log(arguments);
// });



// var cluster = new Redis.Cluster([{
//   port: 6380,
//   host: '127.0.0.1'
// }, {
//   port: 6381,
//   host: '127.0.0.1'
// }], { showFriendlyErrorStack: true });

// cluster.multi().set('foo', 'bar').get('foo2').exec(console.log);
// cluster.pipeline().set('foo', 'bar').get('foo2').exec(console.log);


// setTimeout(function () {
//   // cluster.disconnect();
// }, 2000);

// cluster.get('foo3', function (err, res) {
//   console.log(err, res);
// });

// cluster.defineCommand('testGet', {
//   numberOfKeys: 1,
//   lua: 'return redis.call("mget", KEYS[1], ARGV[1])'
// });

// cluster.set('foo', 'bar');
// cluster.set('foo2', 'bar1');
// cluster.set('{foo}2', 'bar2');
// setInterval(function () {
//   cluster.testGet('foo', '{foo}2', console.log);
// }, 1000);

// // cluster.testGet('foo', '{fo}2', function (err, res) {
// //   console.log(err, res);
// // });
// // var redis = new Redis(6388, '177.22.22.2', {
// //   enableReadyCheck: false
// // });
// // redis.on('end', function (err) {
// //   console.log(err)
// // });
// redis.disconnect();
// var redis = new Redis({
//   sentinels: [
//     { host: '127.0.0.1', port: '26379' },
//     { host: '127.0.0.1', port: '26380' },
//   ],
//   name: 'master1',
//   role: 'master'
// });
// redis.set('foo', 'bar', function () {
//   console.log(arguments);
//   // redis.disconnect();
// });

// var i = 0;
// setInterval(function () {
//   redis.set('foo', 'bar', function () {
//     if (arguments[1] === 'bar') {
//       console.log(++i);
//     } else {
//       console.log(arguments);
//     }
//   });
// }, 300);

// redis.defineCommand('loop', {
//   numberOfKeys: 5,
//   lua: 'return'
// });

// redis.monitor(function (err, monitor) {
//   monitor.on('monitor', function (time, args) {
//   });
// });

// redis.pipeline().get('foo').set('foo', 'cc').get('foo').exec(function (err, result) {
//   console.log(err, result);
// });

//

// setTimeout(function () {
//   var multi = redis.multi();
//   multi.set('foo', 'bar').get('foo').exec(function (err, results) {
//     console.log(err, results);
//   });
// }, 2000);

// var pipeline = true;
// if (!pipeline) {
//   setTimeout(function () {
//     var pending = 0;
//     var start = new Date();
//     var callback = function () {
//       if (!--pending) {
//         console.log(new Date() - start);
//       }
//     };
//     for (var i = 0; i < 1000; ++i) {
//       pending += 1;
//       redis.get('foo', callback);
//     }
//   }, 1000);
// } else {
//   setTimeout(function () {
//     var pipe = redis.pipeline();
//     var start = new Date();
//     for (var i = 0; i < 1000; ++i) {
//       pipe.get('foo');
//     }
//     pipe.exec(function () {
//       console.log(new Date() - start);
//     });
//   }, 1000);
// }
